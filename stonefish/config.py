import yaml
from dataclasses import dataclass
from argparse import ArgumentParser

from stonefish.dataset import ChessData, TTTData
from stonefish.slogging import Logger
from stonefish.model import BaseModel
from stonefish.rep import BoardRep, MoveRep
from stonefish.ttt import TTTBoardRep, TTTMoveRep
from torch.utils.data import Dataset, DataLoader
import torch.optim as optim

from typing import Any, Dict


@dataclass(frozen=True)
class LazyConstructor:
    fn: Any
    kwargs: Dict

    def __getitem__(self, key):
        if key == "class":
            return self.fn
        else:
            return self.kwargs.__getitem__(key)

    def __setitem__(self, key, value):
        if key == "class":
            self.fn = value
        else:
            self.kwargs.__setitem__(key, value)

    def __call__(self, *args):

        for (k, v) in self.kwargs.items():
            if isinstance(v, LazyConstructor):
                self.kwargs[k] = v()

        return self.fn(*args, **self.kwargs)

    def __repr__(self):
        d = {"class": self.fn}
        d.update(self.kwargs)
        return str(d)

    def __str__(self):
        return self.__repr__()

    def keys(self):
        return ["class"] + list(self.kwargs.keys())

    def items(self):
        keys = self.keys()
        return [(k, self.__getitem__(k)) for k in keys]


def make_basic_constructor(type_, name):
    def _constructor(loader, node):
        value = loader.construct_mapping(node)
        return type_(**value)

    yaml.add_constructor("!" + name, _constructor)


def make_lazy_constructor(type_, name):
    def _constructor(loader, node):
        kwargs = loader.construct_mapping(node)
        return LazyConstructor(type_, kwargs)

    yaml.add_constructor("!" + name, _constructor)


make_lazy_constructor(TTTData, "TTTData")
make_lazy_constructor(ChessData, "ChessData")
make_lazy_constructor(BaseModel, "BaseModel")
make_lazy_constructor(DataLoader, "DataLoader")

for o in [
    "Adadelta",
    "Adagrad",
    "Adam",
    "AdamW",
    "SparseAdam",
    "Adamax",
    "ASGD",
    "LBFGS",
    "RMSprop",
    "Rprop",
    "SGD",
]:
    make_lazy_constructor(getattr(optim, o), o)


def logging_constructor(loader, node):
    value = loader.construct_mapping(node)
    Logger.init(**value)
    return Logger


yaml.add_constructor("!Logger", logging_constructor)


def make_type_constructor(type_, name):
    def _constructor(loader, node):
        return type_

    yaml.add_constructor("!" + name, _constructor)


make_type_constructor(TTTBoardRep, "TTTBoardRep")
make_type_constructor(TTTMoveRep, "TTTMoveRep")
make_type_constructor(BoardRep, "BoardRep")
make_type_constructor(MoveRep, "MoveRep")


def load_config(path):
    out = yaml.load(open(path, "r"), yaml.UnsafeLoader)
    return out


def get_all_keys(config):

    keys = []

    for (k, v) in config.items():
        if hasattr(v, "keys"):
            subkeys = get_all_keys(v)
            for sk in subkeys:
                keys.append(".".join([k, sk]))
        else:
            keys.append(k)

    return keys


def dot_access(nested_dict, dot_key):
    keys = dot_key.split(".")
    d = nested_dict
    for k in keys:
        d = d[k]
    return d


def dot_set(nested_dict, dot_key, value):
    keys = dot_key.split(".")
    d = nested_dict
    for k in keys[:-1]:
        d = d[k]
    d[keys[-1]] = value
    return d


def create_parser(path, config):
    key_pairs = get_all_keys(config)

    parser = ArgumentParser(
        description=f"""
This argument parser was autogenerated from the file {path}. This allows you to
overwrite specific YAML values on the fly. The options listed here do not
entail an exhaustive list of the things that you can configure. For more
information on possible kwargs, refer to the class definition of the object in
question. 
    """
    )

    parser.add_argument(f"config_file", help="YAML config file")
    for k in key_pairs:
        current = dot_access(config, k)
        parser.add_argument(f"--{k}", type=type(current))

    return parser


def load_config_and_parse_cli(path):
    config = load_config(path)
    parser = create_parser(path, config)
    args = parser.parse_args()

    for (k, v) in vars(args).items():
        if v and k != "config_file":
            dot_set(config, k, v)
    return config
